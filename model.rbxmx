<roblox version="4">
  <Item class="Script" referent="0">
    <Properties>
      <string name="Name">model</string>
      <string name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- October 10, 2019, 6:20 PM Pacific Daylight Time
-- Hash: ee740c299c3e15c3f00a82e1eb0760258d15344a

print("Hello from my roblox-ts model!");
]]></string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">include</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
	Forked from LPGhatguy/roblox-lua-promise, modified for roblox-ts.
]]

local PROMISE_DEBUG = false

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	local len = select("#", ...)

	return len, { ... }
end

--[[
	wpcallPacked is a version of xpcall that:
	* Returns the length of the result first
	* Returns the result packed into a table
	* Passes extra arguments through to the passed function; xpcall doesn't
	* Issues a warning if PROMISE_DEBUG is enabled
]]
local function wpcallPacked(f, ...)
	local argsLength, args = pack(...)

	local body = function()
		return f(unpack(args, 1, argsLength))
	end

	local resultLength, result = pack(xpcall(body, debug.traceback))

	-- If promise debugging is on, warn whenever a pcall fails.
	-- This is useful for debugging issues within the Promise implementation
	-- itself.
	if PROMISE_DEBUG and not result[1] then
		warn(result[2])
	end

	return resultLength, result
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(callback, resolve, reject)
	return function(...)
		local resultLength, result = wpcallPacked(callback, ...)
		local ok = result[1]

		if ok then
			resolve(unpack(result, 2, resultLength))
		else
			reject(unpack(result, 2, resultLength))
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local function createSymbol(name)
	assert(type(name) == "string", "createSymbol requires `name` to be a string.")

	local symbol = newproxy(true)

	getmetatable(symbol).__tostring = function()
		return ("Symbol(%s)"):format(name)
	end

	return symbol
end

local PromiseMarker = createSymbol("PromiseMarker")

local Promise = {}
Promise.prototype = {}
Promise.__index = Promise.prototype

Promise.Status = {
	Started = createSymbol("Started"),
	Resolved = createSymbol("Resolved"),
	Rejected = createSymbol("Rejected"),
	Cancelled = createSymbol("Cancelled"),
}

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	For example:

		local function get(url)
			return Promise.new(function(resolve, reject)
				spawn(function()
					resolve(HttpService:GetAsync(url))
				end)
			end)
		end

		get("https://google.com")
			:andThen(function(stuff)
				print("Got some stuff!", stuff)
			end)

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise.new(callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		-- A tag to identify us as a promise
		[PromiseMarker] = true,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- If an error occurs with no observers, this will be set.
		_unhandledRejection = false,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation.
		_parent = parent,

		-- The number of consumers attached to this promise. This is needed so that
		-- we don't propagate promise cancellations when there are still uncancelled
		-- consumers.
		_numConsumers = 0,
	}

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		assert(type(cancellationHook) == "function", "onCancel must be called with a function as its first argument.")

		if self._status == Promise.Status.Cancelled then
			cancellationHook()
		else
			self._cancellationHook = cancellationHook
		end
	end

	local _, result = wpcallPacked(callback, resolve, reject, onCancel)
	local ok = result[1]
	local err = result[2]

	if not ok and self._status == Promise.Status.Started then
		reject(err)
	end

	return self
end

--[[
	Fast spawn: Spawns a thread with predictable timing.
	Runs immediately instead of first cycle being deferred.
]]
function Promise.spawn(callback, ...)
	local spawnBindable = Instance.new("BindableEvent")
	local args = { ... }
	local length = select("#", ...)
	spawnBindable.Event:Connect(function()
		callback(unpack(args, 1, length))
	end)
	spawnBindable:Fire()
	spawnBindable:Destroy()
end

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(value)
	return Promise.new(function(resolve)
		resolve(value)
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(value)
	return Promise.new(function(_, reject)
		reject(value)
	end)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise.all(promises)
	if type(promises) ~= "table" then
		error("Please pass a list of promises to Promise.all", 2)
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i = 1, #promises do
		if not Promise.is(promises[i]) then
			error(("Non-promise value passed into Promise.all at index #%d"):format(i), 2)
		end
	end

	return Promise.new(function(resolve, reject)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			resolvedValues[i] = ...
			resolvedCount = resolvedCount + 1

			if resolvedCount == #promises then
				resolve(resolvedValues)
			end
		end

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i = 1, #promises do
			promises[i]:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					reject(...)
				end
			)
		end
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	return object[PromiseMarker] == true
end

function Promise.prototype:getStatus()
	return self._status
end

function Promise.prototype:isRejected()
	return self._status == Promise.Status.Rejected
end

function Promise.prototype:isResolved()
	return self._status == Promise.Status.Resolved
end

function Promise.prototype:isPending()
	return self._status == Promise.Status.Started
end

function Promise.prototype:isCancelled()
	return self._status == Promise.Status.Cancelled
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:andThen(successHandler, failureHandler)
	self._unhandledRejection = false
	self._numConsumers = self._numConsumers + 1

	-- Create a new promise to follow this part of the chain
	return Promise.new(function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject("Promise is cancelled")
		end
	end, self)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	return self:andThen(nil, failureCallback)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled()
	self._numConsumers = self._numConsumers - 1

	if self._numConsumers <= 0 then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:finally(finallyHandler)
	self._numConsumers = self._numConsumers + 1

	-- Return a promise chained off of this promise
	return Promise.new(function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(finallyHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback()
		end
	end, self)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:await()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local result
		local resultLength
		local bindable = Instance.new("BindableEvent")

		self:andThen(
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(true)
			end,
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(false)
			end
		)
		self:finally(function()
			bindable:Fire(nil)
		end)

		local ok = bindable.Event:Wait()
		bindable:Destroy()

		if ok == nil then
			-- If cancelled, we return nil.
			return nil
		end

		return ok, unpack(result, 1, resultLength)
	elseif self._status == Promise.Status.Resolved then
		return true, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return false, unpack(self._values, 1, self._valuesLength)
	end

	-- If the promise is cancelled, fall through to nil.
	return nil
end

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = (
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s"
			):format(
				self._source
			)
			warn(message)
		end

		(...):andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				self:_reject(...)
			end
		)

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		self._unhandledRejection = true
		local err = tostring((...))

		spawn(function()
			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
				err,
				self._source
			)
			warn(message)
		end)
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		callback()
	end
end

return Promise
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">RuntimeLib</string>
          <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local ReplicatedFirst
if not __LEMUR__ then
	ReplicatedFirst = game:GetService("ReplicatedFirst")
end

local TS = {}

-- runtime classes
TS.Promise = Promise

local Symbol do
	Symbol = {}
	Symbol.__index = Symbol
	setmetatable(Symbol, {
		__call = function(_, description)
			local self = setmetatable({}, Symbol)
			self.description = "Symbol(" .. (description or "") .. ")"
			return self
		end
	})

	local symbolRegistry = setmetatable({}, {
		__index = function(self, k)
			self[k] = Symbol(k)
			return self[k]
		end
	})

	function Symbol:toString()
		return self.description
	end

	Symbol.__tostring = Symbol.toString

	-- Symbol.for
	function Symbol.getFor(key)
		return symbolRegistry[key]
	end

	function Symbol.keyFor(goalSymbol)
		for key, symbol in pairs(symbolRegistry) do
			if symbol == goalSymbol then
				return key
			end
		end
	end
end

TS.Symbol = Symbol
TS.Symbol_iterator = Symbol("Symbol.iterator")

-- module resolution
function TS.getModule(object, moduleName)
	if not __LEMUR__ and object:IsDescendantOf(ReplicatedFirst) then
		warn("node_modules should not be used from ReplicatedFirst")
	end

	-- ensure modules have fully replicated
	if not __LEMUR__ and RunService:IsClient() and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local globalModules = script.Parent:FindFirstChild("node_modules")
	if not globalModules then
		error("Could not find any modules!", 2)
	end

	repeat
		local modules = object:FindFirstChild("node_modules")
		if modules then
			local module = modules:FindFirstChild(moduleName)
			if module then
				return module
			end
		end
		object = object.Parent
	until object == nil or object == globalModules

	return globalModules:FindFirstChild(moduleName) or error("Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(caller, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error("Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[caller] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error("Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error("Invalid module access! Do you have two TS runtimes trying to import this? " .. module:GetFullName(), 2)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[caller] == module then -- Thread-safe cleanup!
		currentlyLoading[caller] = nil
	end

	return data
end

function TS.exportNamespace(module, ancestor)
	for key, value in pairs(module) do
		ancestor[key] = value
	end
end

-- general utility functions
function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local ok, result = promise:await()
	if ok then
		return result
	else
		error(ok == nil and "The awaited Promise was cancelled" or result, 2)
	end
end

function TS.add(a, b)
	if type(a) == "string" or type(b) == "string" then
		return a .. b
	else
		return a + b
	end
end

function TS.bit_lrsh(a, b)
	local absA = math.abs(a)
	local result = bit32.rshift(absA, b)
	if a == absA then
		return result
	else
		return -result - 1
	end
end

-- utility functions
local function copy(object)
	local result = {}
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopy(object)
	local result = {}
	for k, v in pairs(object) do
		if type(v) == "table" then
			result[k] = deepCopy(v)
		else
			result[k] = v
		end
	end
	return result
end

local function deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

-- Object static functions

function TS.Object_keys(object)
	local result = {}
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function TS.Object_values(object)
	local result = {}
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function TS.Object_entries(object)
	local result = {}
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function TS.Object_assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

TS.Object_copy = copy

TS.Object_deepCopy = deepCopy

TS.Object_deepEquals = deepEquals

local function toString(data)
	return HttpService:JSONEncode(data)
end

TS.Object_toString = toString

-- string macro functions
function TS.string_find_wrap(a, b, ...)
	if a then
		return a - 1, b - 1, ...
	end
end

-- array macro functions
local function array_copy(list)
	local result = {}
	for i = 1, #list do
		result[i] = list[i]
	end
	return result
end

TS.array_copy = array_copy

function TS.array_entries(list)
	local result = {}
	for key = 1, #list do
		result[key] = { key - 1, list[key] }
	end
	return result
end

function TS.array_forEach(list, callback)
	for i = 1, #list do
		callback(list[i], i - 1, list)
	end
end

local function array_map(list, callback)
	local result = {}
	for i = 1, #list do
		result[i] = callback(list[i], i - 1, list)
	end
	return result
end

TS.array_map = array_map

function TS.array_filter(list, callback)
	local result = {}
	for i = 1, #list do
		local v = list[i]
		if callback(v, i - 1, list) == true then
			result[#result + 1] = v
		end
	end
	return result
end

local function sortFallback(a, b)
	return tostring(a) < tostring(b)
end

function TS.array_sort(list, callback)
	local sorted = array_copy(list)

	if callback then
		table.sort(sorted, function(a, b)
			return 0 < callback(a, b)
		end)
	else
		table.sort(sorted, sortFallback)
	end

	return sorted
end

TS.array_toString = toString

function TS.array_slice(list, startI, endI)
	local length = #list

	if startI == nil then startI = 0 end
	if endI == nil then endI = length end

	if startI < 0 then startI = length + startI end
	if endI < 0 then endI = length + endI end

	local result = {}

	for i = startI + 1, endI do
		result[i - startI] = list[i]
	end

	return result
end

function TS.array_splice(list, start, deleteCount, ...)
	local len = #list
	local actualStart
	if start < 0 then
		actualStart = len + start
		if actualStart < 0 then
			actualStart = 0
		end
	else
		if start < len then
			actualStart = start
		else
			actualStart = len
		end
	end
	local items = { ... }
	local itemCount = #items
	local actualDeleteCount
	if start == nil then
		actualDeleteCount = 0
	elseif deleteCount == nil then
		actualDeleteCount = len - actualStart
	else
		if deleteCount < 0 then
			deleteCount = 0
		end
		actualDeleteCount = len - actualStart
		if deleteCount < actualDeleteCount then
			actualDeleteCount = deleteCount
		end
	end
	local out = {}
	local k = 0
	while k < actualDeleteCount do
		local from = actualStart + k
		if list[from + 1] then
			out[k + 1] = list[from + 1]
		end
		k = k + 1
	end
	if itemCount < actualDeleteCount then
		k = actualStart
		while k < len - actualDeleteCount do
			local from = k + actualDeleteCount
			local to = k + itemCount
			if list[from + 1] then
				list[to + 1] = list[from + 1]
			else
				list[to + 1] = nil
			end
			k = k + 1
		end
		k = len
		while k > len - actualDeleteCount + itemCount do
			list[k] = nil
			k = k - 1
		end
	elseif itemCount > actualDeleteCount then
		k = len - actualDeleteCount
		while k > actualStart do
			local from = k + actualDeleteCount
			local to = k + itemCount
			if list[from] then
				list[to] = list[from]
			else
				list[to] = nil
			end
			k = k - 1
		end
	end
	k = actualStart
	for i = 1, #items do
		list[k + 1] = items[i]
		k = k + 1
	end
	k = #list
	while k > len - actualDeleteCount + itemCount do
		list[k] = nil
		k = k - 1
	end
	return out
end

function TS.array_some(list, callback)
	for i = 1, #list do
		if callback(list[i], i - 1, list) == true then
			return true
		end
	end
	return false
end

function TS.array_every(list, callback)
	for i = 1, #list do
		if callback(list[i], i - 1, list) == false then
			return false
		end
	end
	return true
end

function TS.array_includes(list, item, startingIndex)
	for i = (startingIndex or 0) + 1, #list do
		if list[i] == item then
			return true
		end
	end
	return false
end

function TS.array_indexOf(list, value, fromIndex)
	for i = (fromIndex or 0) + 1, #list do
		if value == list[i] then
			return i - 1
		end
	end
	return -1
end

function TS.array_lastIndexOf(list, value, fromIndex)
	for i = (fromIndex or #list - 1) + 1, 1, -1 do
		if value == list[i] then
			return i - 1
		end
	end
	return -1
end

function TS.array_reverse(list)
	local result = {}
	local length = #list
	local n = length + 1
	for i = 1, length do
		result[i] = list[n - i]
	end
	return result
end

function TS.array_reduce(list, callback, ...)
	local first = 1
	local last = #list
	local accumulator
	-- support `nil` initialValues
	if select("#", ...) == 0 then
		if last == 0 then
			error("Reduce of empty array with no initial value at Array.reduce", 2)
		end
		accumulator = list[first]
		first = first + 1
	else
		accumulator = ...
	end
	for i = first, last do
		accumulator = callback(accumulator, list[i], i - 1, list)
	end
	return accumulator
end

function TS.array_reduceRight(list, callback, ...)
	local first = #list
	local last = 1
	local accumulator
	-- support `nil` initialValues
	if select("#", ...) == 0 then
		if first == 0 then
			error("Reduce of empty array with no initial value at Array.reduceRight", 2)
		end
		accumulator = list[first]
		first = first - 1
	else
		accumulator = ...
	end
	for i = first, last, -1 do
		accumulator = callback(accumulator, list[i], i - 1, list)
	end
	return accumulator
end

function TS.array_unshift(list, ...)
	local n = #list
	local argsLength = select("#", ...)
	for i = n, 1, -1 do
		list[i + argsLength] = list[i]
	end
	for i = 1, argsLength do
		list[i] = select(i, ...)
	end
	return n + argsLength
end

local function array_push_apply(list, ...)
	local len = #list
	for i = 1, select("#", ...) do
		local list2 = select(i, ...)
		local len2 = #list2
		for j = 1, len2 do
			list[len + j] = list2[j]
		end
		len = len + len2
	end
	return len
end

TS.array_push_apply = array_push_apply

function TS.array_push_stack(list, ...)
	local len = #list
	local len2 = select("#", ...)
	for i = 1, len2 do
		list[len + i] = select(i, ...)
	end
	return len + len2
end

function TS.array_concat(...)
	local result = {}
	array_push_apply(result, ...)
	return result
end

function TS.array_join(list, separator)
	return table.concat(array_map(list, tostring), separator or ",")
end

function TS.array_find(list, callback)
	for i = 1, #list do
		local v = list[i]
		if callback(v, i - 1, list) == true then
			return v
		end
	end
end

function TS.array_findIndex(list, callback)
	for i = 0, #list - 1 do
		if callback(list[i + 1], i, list) == true then
			return i
		end
	end
	return -1
end

local function array_flat_helper(list, depth, count, result)
	for i = 1, #list do
		local v = list[i]

		if type(v) == "table" and depth ~= 0 then
			count = array_flat_helper(v, depth - 1, count, result)
		else
			count = count + 1
			result[count] = v
		end
	end

	return count
end

function TS.array_flat(list, depth)
	local result = {}
	array_flat_helper(list, depth or 1, 0, result)
	return result
end

function TS.array_fill(list, value, from, to)
	local length = #list

	if from == nil then
		from = 0
	elseif from < 0 then
		from = from + length
	end

	if to == nil or to > length then
		to = length
	elseif to < 0 then
		to = to + length
	end

	for i = from + 1, to do
		list[i] = value
	end

	return list
end

function TS.array_copyWithin(list, target, from, to)
	local length = #list

	if target < 0 then
		target = target + length
	end

	if from == nil then
		from = 0
	elseif from < 0 then
		from = from + length
	end

	if to == nil or to > length then
		to = length
	elseif to < 0 then
		to = to + length
	end

	local tf = target - from
	local overshoot = to + tf - length

	if overshoot > 0 then
		to = from + length - target
	end

	for i = to, from + 1, -1 do
		list[i + tf] = list[i]
	end

	return list
end

TS.array_deepCopy = deepCopy

TS.array_deepEquals = deepEquals

-- map macro functions

function TS.map_new(pairs)
	local result = {}
	if pairs then
		for i = 1, #pairs do
			local pair = pairs[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

function TS.map_clear(map)
	for key in pairs(map) do
		map[key] = nil
	end
end

local function getNumKeys(map)
	local result = 0
	for _ in pairs(map) do
		result = result + 1
	end
	return result
end

TS.map_size = getNumKeys
TS.map_entries = TS.Object_entries

function TS.map_forEach(map, callback)
	for key, value in pairs(map) do
		callback(value, key, map)
	end
end

TS.map_keys = TS.Object_keys

TS.map_values = TS.Object_values
TS.map_toString = toString

-- set macro functions

function TS.set_new(values)
	local result = {}
	if values then
		for i = 1, #values do
			result[values[i]] = true
		end
	end
	return result
end

TS.set_clear = TS.map_clear

function TS.set_forEach(set, callback)
	for key in pairs(set) do
		callback(key, key, set)
	end
end

function TS.set_union(set1, set2)
	local result = {}

	for value in pairs(set1) do
		result[value] = true
	end

	for value in pairs(set2) do
		result[value] = true
	end

	return result
end

function TS.set_intersect(set1, set2)
	local result = {}

	for value in pairs(set1) do
		if set2[value] then
			result[value] = true
		end
	end

	return result
end

function TS.set_isDisjointWith(set1, set2)
	for value in pairs(set1) do
		if set2[value] then
			return false
		end
	end
	return true
end

function TS.set_isSubsetOf(set1, set2)
	for value in pairs(set1) do
		if set2[value] == nil then
			return false
		end
	end

	return true
end

function TS.set_difference(set1, set2)
	local result = {}
	for value in pairs(set1) do
		if set2[value] == nil then
			result[value] = true
		end
	end
	return result
end

TS.set_values = TS.Object_keys

TS.set_size = getNumKeys

TS.set_toString = toString

-- spread cache functions
function TS.string_spread(str)
	local results = {}
	local count = 0
	for char in string.gmatch(str, "[%z\1-\127\194-\244][\128-\191]*") do
		count = count + 1
		results[count] = char
	end
	return results
end

function TS.iterableCache(iter)
	local results = {}
	local count = 0
	for _0 in iter.next do
		if _0.done then break end
		count = count + 1
		results[count] = _0.value
	end
	return results
end

local function package(...)
	return select("#", ...), {...}
end

function TS.iterableFunctionCache(iter)
	local results = {}
	local count = 0

	while true do
		local size, t = package(iter());
		if size == 0 then break end
		count = count + 1
		results[count] = t
	end

	return results
end

-- roact functions

function TS.Roact_combine(...)
	local args = { ... }
	local result = {}
	for i = 1, #args do
		for key, value in pairs(args[i]) do
			if (type(key) == "number") then
				table.insert(result, value)
			else
				result[key] = value
			end
		end
	end
	return result
end

-- opcall

function TS.opcall(func, ...)
	local success, valueOrErr = pcall(func, ...)
	if success then
		return {
			success = true,
			value = valueOrErr,
		}
	else
		return {
			success = false,
			error = valueOrErr,
		}
	end
end

return TS
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="4">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="5">
          <Properties>
            <string name="Name">inspect</string>
          </Properties>
          <Item class="ModuleScript" referent="6">
            <Properties>
              <string name="Name">inspect</string>
              <string name="Source"><![CDATA[local inspect ={
	_VERSION = 'inspect.lua 3.1.0',
	_URL     = 'http://github.com/kikito/inspect.lua',
	_DESCRIPTION = 'human-readable representations of tables',
	_LICENSE = [[
	  MIT LICENSE

	  Copyright (c) 2013 Enrique García Cota

	  Permission is hereby granted, free of charge, to any person obtaining a
	  copy of this software and associated documentation files (the
	  "Software"), to deal in the Software without restriction, including
	  without limitation the rights to use, copy, modify, merge, publish,
	  distribute, sublicense, and/or sell copies of the Software, and to
	  permit persons to whom the Software is furnished to do so, subject to
	  the following conditions:

	  The above copyright notice and this permission notice shall be included
	  in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	]]
  }

  local tostring = tostring

  inspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})
  inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})

  local function rawpairs(t)
	return next, t, nil
  end

  -- Apostrophizes the string if it has quotes, but not aphostrophes
  -- Otherwise, it returns a regular quoted string
  local function smartQuote(str)
	if str:match('"') and not str:match("'") then
	  return "'" .. str .. "'"
	end
	return '"' .. str:gsub('"', '\\"') .. '"'
  end

  -- \a => '\\a', \0 => '\\0', 31 => '\31'
  local shortControlCharEscapes = {
	["\a"] = "\\a",  ["\b"] = "\\b", ["\f"] = "\\f", ["\n"] = "\\n",
	["\r"] = "\\r",  ["\t"] = "\\t", ["\v"] = "\\v"
  }
  local longControlCharEscapes = {} -- \a => nil, \0 => \000, 31 => \031
  for i=0, 31 do
	local ch = string.char(i)
	if not shortControlCharEscapes[ch] then
	  shortControlCharEscapes[ch] = "\\"..i
	  longControlCharEscapes[ch]  = string.format("\\%03d", i)
	end
  end

  local function escape(str)
	return (str:gsub("\\", "\\\\")
			   :gsub("(%c)%f[0-9]", longControlCharEscapes)
			   :gsub("%c", shortControlCharEscapes))
  end

  local function isIdentifier(str)
	return type(str) == 'string' and str:match( "^[_%a][_%a%d]*$" )
  end

  local function isSequenceKey(k, sequenceLength)
	return type(k) == 'number'
	   and 1 <= k
	   and k <= sequenceLength
	   and math.floor(k) == k
  end

  local defaultTypeOrders = {
	['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,
	['function'] = 5, ['userdata'] = 6, ['thread'] = 7
  }

  local function sortKeys(a, b)
	local ta, tb = type(a), type(b)

	-- strings and numbers are sorted numerically/alphabetically
	if ta == tb and (ta == 'string' or ta == 'number') then return a < b end

	local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]
	-- Two default types are compared according to the defaultTypeOrders table
	if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]
	elseif dta     then return true  -- default types before custom ones
	elseif dtb     then return false -- custom types after default ones
	end

	-- custom types are sorted out alphabetically
	return ta < tb
  end

  -- For implementation reasons, the behavior of rawlen & # is "undefined" when
  -- tables aren't pure sequences. So we implement our own # operator.
  local function getSequenceLength(t)
	local len = 1
	local v = rawget(t,len)
	while v ~= nil do
	  len = len + 1
	  v = rawget(t,len)
	end
	return len - 1
  end

  local function getNonSequentialKeys(t)
	local keys, keysLength = {}, 0
	local sequenceLength = getSequenceLength(t)
	for k,_ in rawpairs(t) do
	  if not isSequenceKey(k, sequenceLength) then
		keysLength = keysLength + 1
		keys[keysLength] = k
	  end
	end
	table.sort(keys, sortKeys)
	return keys, keysLength, sequenceLength
  end

  local function countTableAppearances(t, tableAppearances)
	tableAppearances = tableAppearances or {}

	if type(t) == 'table' then
	  if not tableAppearances[t] then
		tableAppearances[t] = 1
		for k,v in rawpairs(t) do
		  countTableAppearances(k, tableAppearances)
		  countTableAppearances(v, tableAppearances)
		end
		countTableAppearances(getmetatable(t), tableAppearances)
	  else
		tableAppearances[t] = tableAppearances[t] + 1
	  end
	end

	return tableAppearances
  end

  local copySequence = function(s)
	local copy, len = {}, #s
	for i=1, len do copy[i] = s[i] end
	return copy, len
  end

  local function makePath(path, ...)
	local keys = {...}
	local newPath, len = copySequence(path)
	for i=1, #keys do
	  newPath[len + i] = keys[i]
	end
	return newPath
  end

  local function processRecursive(process, item, path, visited)
	if item == nil then return nil end
	if visited[item] then return visited[item] end

	local processed = process(item, path)
	if type(processed) == 'table' then
	  local processedCopy = {}
	  visited[item] = processedCopy
	  local processedKey

	  for k,v in rawpairs(processed) do
		processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)
		if processedKey ~= nil then
		  processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)
		end
	  end

	  local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)
	  if type(mt) ~= 'table' then mt = nil end -- ignore not nil/table __metatable field
	  setmetatable(processedCopy, mt)
	  processed = processedCopy
	end
	return processed
  end



  -------------------------------------------------------------------

  local Inspector = {}
  local Inspector_mt = {__index = Inspector}

  function Inspector:puts(...)
	local args   = {...}
	local buffer = self.buffer
	local len    = #buffer
	for i=1, #args do
	  len = len + 1
	  buffer[len] = args[i]
	end
  end

  function Inspector:down(f)
	self.level = self.level + 1
	f()
	self.level = self.level - 1
  end

  function Inspector:tabify()
	self:puts(self.newline, string.rep(self.indent, self.level))
  end

  function Inspector:alreadyVisited(v)
	return self.ids[v] ~= nil
  end

  function Inspector:getId(v)
	local id = self.ids[v]
	if not id then
	  local tv = type(v)
	  id              = (self.maxIds[tv] or 0) + 1
	  self.maxIds[tv] = id
	  self.ids[v]     = id
	end
	return tostring(id)
  end

  function Inspector:putKey(k)
	if isIdentifier(k) then return self:puts(k) end
	self:puts("[")
	self:putValue(k)
	self:puts("]")
  end

  function Inspector:putTable(t)
	if t == inspect.KEY or t == inspect.METATABLE then
	  self:puts(tostring(t))
	elseif self:alreadyVisited(t) then
	  self:puts('<table ', self:getId(t), '>')
	elseif self.level >= self.depth then
	  self:puts('{...}')
	else
	  if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end

	  local nonSequentialKeys, nonSequentialKeysLength, sequenceLength = getNonSequentialKeys(t)
	  local mt                = getmetatable(t)

	  self:puts('{')
	  self:down(function()
		local count = 0
		for i=1, sequenceLength do
		  if count > 0 then self:puts(',') end
		  self:puts(' ')
		  self:putValue(t[i])
		  count = count + 1
		end

		for i=1, nonSequentialKeysLength do
		  local k = nonSequentialKeys[i]
		  if count > 0 then self:puts(',') end
		  self:tabify()
		  self:putKey(k)
		  self:puts(' = ')
		  self:putValue(t[k])
		  count = count + 1
		end

		if type(mt) == 'table' then
		  if count > 0 then self:puts(',') end
		  self:tabify()
		  self:puts('<metatable> = ')
		  self:putValue(mt)
		end
	  end)

	  if nonSequentialKeysLength > 0 or type(mt) == 'table' then -- result is multi-lined. Justify closing }
		self:tabify()
	  elseif sequenceLength > 0 then -- array tables have one extra space before closing }
		self:puts(' ')
	  end

	  self:puts('}')
	end
  end

  function Inspector:putValue(v)
	local tv = type(v)

	if tv == 'string' then
	  self:puts(smartQuote(escape(v)))
	elseif tv == 'number' or tv == 'boolean' or tv == 'nil' or
		   tv == 'cdata' or tv == 'ctype' then
	  self:puts(tostring(v))
	elseif tv == 'table' then
	  self:putTable(v)
	else
	  self:puts('<', tv, ' ', self:getId(v), '>')
	end
  end

  -------------------------------------------------------------------

  function inspect.inspect(root, options)
	options       = options or {}

	local depth   = options.depth   or math.huge
	local newline = options.newline or '\n'
	local indent  = options.indent  or '  '
	local process = options.process

	if process then
	  root = processRecursive(process, root, {}, {})
	end

	local inspector = setmetatable({
	  depth            = depth,
	  level            = 0,
	  buffer           = {},
	  ids              = {},
	  maxIds           = {},
	  newline          = newline,
	  indent           = indent,
	  tableAppearances = countTableAppearances(root)
	}, Inspector_mt)

	inspector:putValue(root)

	return table.concat(inspector.buffer)
  end

  setmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })

  return inspect
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="7">
          <Properties>
            <string name="Name">roact</string>
          </Properties>
          <Item class="Folder" referent="8">
            <Properties>
              <string name="Name">roact</string>
            </Properties>
            <Item class="ModuleScript" referent="9">
              <Properties>
                <string name="Name">lib</string>
                <string name="Source">--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local Core = require(script.Core)
local GlobalConfig = require(script.GlobalConfig)
local Instrumentation = require(script.Instrumentation)
local Reconciler = require(script.Reconciler)
local ReconcilerCompat = require(script.ReconcilerCompat)

local Roact = {
	Change = require(script.Change),
	Component = require(script.Component),
	createElement = require(script.createElement),
	createRef = require(script.createRef),
	Event = require(script.Event),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),

	Children = Core.Children,
	Element = Core.Element,
	None = Core.None,
	Portal = Core.Portal,
	Ref = Core.Ref,

	mount = Reconciler.mount,
	unmount = Reconciler.unmount,
	reconcile = Reconciler.reconcile,

	reify = ReconcilerCompat.reify,
	teardown = ReconcilerCompat.teardown,

	setGlobalConfig = GlobalConfig.set,
	getGlobalConfigValue = GlobalConfig.getValue,

	-- APIs that may change in the future without warning
	UNSTABLE = {
		getCollectedStats = Instrumentation.getCollectedStats,
		clearCollectedStats = Instrumentation.clearCollectedStats,
	},
}

return Roact</string>
              </Properties>
              <Item class="ModuleScript" referent="10">
                <Properties>
                  <string name="Name">Change</string>
                  <string name="Source">--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("ChangeListener(%s)"):format(self.name)
	end
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			type = Change,
			name = propertyName
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="11">
                <Properties>
                  <string name="Name">Component</string>
                  <string name="Source"><![CDATA[--[[
	The base implementation of a stateful component in Roact.

	Stateful components handle most of their own mounting and reconciliation
	process. Many of the private methods here are invoked by the reconciler.

	Stateful components expose a handful of lifecycle events:
	- didMount
	- willUnmount
	- willUpdate
	- didUpdate
	- (static) getDerivedStateFromProps

	These lifecycle events line up with their semantics in React, and more
	information (and a diagram) is available in the Roact documentation.
]]

local Reconciler = require(script.Parent.Reconciler)
local Core = require(script.Parent.Core)
local GlobalConfig = require(script.Parent.GlobalConfig)
local Instrumentation = require(script.Parent.Instrumentation)

local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)

local Component = {}

-- Locally cache tick so we can minimize impact of calling it for instrumentation
local tick = tick

Component.__index = Component

--[[
	Merge any number of dictionaries into a new dictionary, overwriting keys.

	If a value of `Core.None` is encountered, the key will be removed instead.
	This is necessary because Lua doesn't differentiate between a key being
	missing and a key being set to nil.
]]
local function merge(...)
	local result = {}

	for i = 1, select("#", ...) do
		local entry = select(i, ...)

		for key, value in pairs(entry) do
			if value == Core.None then
				result[key] = nil
			else
				result[key] = value
			end
		end
	end

	return result
end

--[[
	Create a new stateful component.

	Not intended to be a general OO implementation, this function only intends
	to let users extend Component and PureComponent.

	Instead of using inheritance, use composition and props to extend
	components.
]]
function Component:extend(name)
	assert(type(name) == "string", "A name must be provided to create a Roact Component")

	local class = {}

	for key, value in pairs(self) do
		-- We don't want users using 'extend' to create component inheritance
		-- see https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class.__index = class

	setmetatable(class, {
		__tostring = function(self)
			return name
		end
	})

	function class._new(passedProps, context)
		local self = {}

		-- When set to a value, setState will fail, using the given reason to
		-- create a detailed error message.
		-- You can see a list of reasons in invalidSetStateMessages.
		self._setStateBlockedReason = nil

		-- When set to true, setState should not trigger an update, but should
		-- instead just update self.state. Lifecycle events like `init`
		-- can set this to change the behavior of setState slightly.
		self._setStateWithoutUpdate = false

		if class.defaultProps == nil then
			self.props = passedProps
		else
			self.props = merge(class.defaultProps, passedProps)
		end

		self._context = {}

		-- Shallow copy all context values from our parent element.
		if context then
			for key, value in pairs(context) do
				self._context[key] = value
			end
		end

		setmetatable(self, class)

		self.state = {}

		-- Call the user-provided initializer, where state and _props are set.
		if class.init then
			self._setStateWithoutUpdate = true
			class.init(self, self.props)
			self._setStateWithoutUpdate = false
		end

		if class.getDerivedStateFromProps then
			local partialState = class.getDerivedStateFromProps(self.props, self.state)

			if partialState then
				self.state = merge(self.state, partialState)
			end
		end

		return self
	end

	return class
end

--[[
	render is intended to describe what a UI should look like at the current
	point in time.

	The default implementation throws an error, since forgetting to define
	render is usually a mistake.

	The simplest implementation for render is:

		function MyComponent:render()
			return nil
		end

	You should explicitly return nil from functions in Lua to avoid edge cases
	related to none versus nil.
]]
function Component:render()
	local message = (
		"The component %q is missing the 'render' method.\n" ..
		"render must be defined when creating a Roact component!"
	):format(
		tostring(getmetatable(self))
	)

	error(message, 0)
end

--[[
	Used to tell Roact whether this component *might* need to be re-rendered
	given a new set of props and state.

	This method is an escape hatch for when the Roact element creation and
	reconciliation algorithms are not fast enough for specific cases. Poorly
	written shouldUpdate methods *will* cause hard-to-trace bugs.

	If you're thinking of writing a shouldUpdate function, consider using
	PureComponent instead, which provides a good implementation given that your
	data is immutable.

	This function must be faster than the render method in order to be a
	performance improvement.
]]
function Component:shouldUpdate(newProps, newState)
	return true
end

--[[
	Applies new state to the component.

	partialState may be one of two things:
	- A table, which will be merged onto the current state.
	- A function, returning a table to merge onto the current state.

	The table variant generally looks like:

		self:setState({
			foo = "bar",
		})

	The function variant generally looks like:

		self:setState(function(prevState, props)
			return {
				foo = prevState.count + 1,
			})
		end)

	The function variant may also return nil in the callback, which allows Roact
	to cancel updating state and abort the render.

	Future versions of Roact will potentially batch or delay state merging, so
	any state updates that depend on the current state should use the function
	variant.
]]
function Component:setState(partialState)
	-- If setState was disabled, we should check for a detailed message and
	-- display it.
	if self._setStateBlockedReason ~= nil then
		local messageSource = invalidSetStateMessages[self._setStateBlockedReason]

		if messageSource == nil then
			messageSource = invalidSetStateMessages["default"]
		end

		-- We assume that each message has a formatting placeholder for a component name.
		local formattedMessage = string.format(messageSource, tostring(getmetatable(self)))

		error(formattedMessage, 2)
	end

	-- If the partial state is a function, invoke it to get the actual partial state.
	if type(partialState) == "function" then
		partialState = partialState(self.state, self.props)

		-- If partialState is nil, abort the render.
		if partialState == nil then
			return
		end
	end

	local newState = merge(self.state, partialState)

	if self._setStateWithoutUpdate then
		self.state = newState
	else
		self:_update(nil, newState)
	end
end

--[[
	Returns the current stack trace for this component, or nil if the
	elementTracing configuration flag is set to false.
]]
function Component:getElementTraceback()
	return self._handle._element.source
end

--[[
	Notifies the component that new props and state are available. This function
	is invoked by the reconciler.

	If shouldUpdate returns true, this method will trigger a re-render and
	reconciliation step.
]]
function Component:_update(newProps, newState)
	self._setStateBlockedReason = "shouldUpdate"

	-- Compute new derived state.
	-- Get the class - getDerivedStateFromProps is static.
	local class = getmetatable(self)

	-- If newProps are passed, compute derived state and default props
	if newProps then
		if class.getDerivedStateFromProps then
			local derivedState = class.getDerivedStateFromProps(newProps, newState or self.state)

			-- getDerivedStateFromProps can return nil if no changes are necessary.
			if derivedState ~= nil then
				newState = merge(newState or self.state, derivedState)
			end
		end

		if class.defaultProps then
			-- We only allocate another prop table if there are props that are
			-- falling back to their default.
			local replacementProps

			for key in pairs(class.defaultProps) do
				if newProps[key] == nil then
					replacementProps = merge(class.defaultProps, newProps)
					break
				end
			end

			if replacementProps then
				newProps = replacementProps
			end
		end
	end

	local shouldUpdateStart = tick()
	local doUpdate = self:shouldUpdate(newProps or self.props, newState or self.state)
	local shouldUpdateElapsed = tick() - shouldUpdateStart

	if GlobalConfig.getValue("componentInstrumentation") then
		Instrumentation.logShouldUpdate(self._handle, doUpdate, shouldUpdateElapsed)
	end

	self._setStateBlockedReason = nil

	if doUpdate then
		self:_forceUpdate(newProps, newState)
	end
end

--[[
	Forces the component to re-render itself and its children.

	This is essentially the inner portion of _update.

	newProps and newState are optional.
]]
function Component:_forceUpdate(newProps, newState)
	if self.willUpdate then
		self._setStateBlockedReason = "willUpdate"
		self:willUpdate(newProps or self.props, newState or self.state)
		self._setStateBlockedReason = nil
	end

	local oldProps = self.props
	local oldState = self.state

	if newProps then
		self.props = newProps
	end

	if newState then
		self.state = newState
	end

	self._setStateBlockedReason = "render"

	local renderStart = tick()
	local newChildElement = self:render()
	local renderElapsed = tick() - renderStart

	self._setStateBlockedReason = nil

	if GlobalConfig.getValue("componentInstrumentation") then
		Instrumentation.logRenderTime(self._handle, renderElapsed)
	end

	self._setStateBlockedReason = "reconcile"
	if self._handle._child ~= nil then
		-- We returned an element during our last render, update it.
		self._handle._child = Reconciler._reconcileInternal(
			self._handle._child,
			newChildElement
		)
	elseif newChildElement then
		-- We returned nil during our last render, construct a new child.
		self._handle._child = Reconciler._mountInternal(
			newChildElement,
			self._handle._parent,
			self._handle._key,
			self._context
		)
	end
	self._setStateBlockedReason = nil

	if self.didUpdate then
		self:didUpdate(oldProps, oldState)
	end
end

--[[
	Initializes the component instance and attaches it to the given
	instance handle, created by Reconciler._mount.
]]
function Component:_mount(handle)
	self._handle = handle

	self._setStateBlockedReason = "render"

	local renderStart = tick()
	local virtualTree = self:render()
	local renderElapsed = tick() - renderStart

	if GlobalConfig.getValue("componentInstrumentation") then
		Instrumentation.logRenderTime(self._handle, renderElapsed)
	end

	self._setStateBlockedReason = nil

	if virtualTree then
		self._setStateBlockedReason = "reconcile"
		handle._child = Reconciler._mountInternal(
			virtualTree,
			handle._parent,
			handle._key,
			self._context
		)
		self._setStateBlockedReason = nil
	end

	if self.didMount then
		self:didMount()
	end
end

--[[
	Destructs the component and invokes all necessary lifecycle methods.
]]
function Component:_unmount()
	local handle = self._handle

	if self.willUnmount then
		self._setStateBlockedReason = "willUnmount"
		self:willUnmount()
		self._setStateBlockedReason = nil
	end

	-- Stateful components can return nil from render()
	if handle._child then
		Reconciler.unmount(handle._child)
	end

	self._handle = nil
end

return Component
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="12">
                <Properties>
                  <string name="Name">Config</string>
                  <string name="Source">--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables instrumentation of shouldUpdate and render methods for Roact components
	["componentInstrumentation"] = false,
	-- Enables warnings if an element changes type after being rendered.
	["warnOnTypeChange"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

--[[
	Merges two tables together into a new table.
]]
local function join(a, b)
	local new = {}

	for key, value in pairs(a) do
		new[key] = value
	end

	for key, value in pairs(b) do
		new[key] = value
	end

	return new
end

local Config = {}

function Config.new()
	local self = {}

	-- Once configuration has been set, we record a traceback.
	-- That way, if the user mistakenly calls `set` twice, we can point to the
	-- first place it was called.
	self._lastConfigTraceback = nil

	self._currentConfig = defaultConfig

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.getValue = function(...)
		return Config.getValue(self, ...)
	end

	self.reset = function(...)
		return Config.reset(self, ...)
	end

	return self
end

function Config.set(self, configValues)
	if self._lastConfigTraceback then
		local message = (
			"Global configuration can only be set once. Configuration was already set at:%s"
		):format(
			self._lastConfigTraceback
		)

		error(message, 3)
	end

	-- We use 3 as our traceback and error level because all of the methods are
	-- manually bound to 'self', which creates an additional stack frame we want
	-- to skip through.
	self._lastConfigTraceback = debug.traceback("", 3)

	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end
	end

	-- Assign all of the (validated) configuration values in one go.
	self._currentConfig = join(self._currentConfig, configValues)
end

function Config.getValue(self, key)
	if defaultConfig[key] == nil then
		local message = (
			"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
		):format(
			tostring(key),
			typeof(key),
			table.concat(defaultConfigKeys, ", ")
		)

		error(message, 3)
	end

	return self._currentConfig[key]
end

function Config.reset(self)
	self._lastConfigTraceback = nil
	self._currentConfig = defaultConfig
end

return Config</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="13">
                <Properties>
                  <string name="Name">Core</string>
                  <string name="Source">--[[
	Provides a set of markers used for annotating data in Roact.
]]

local Symbol = require(script.Parent.Symbol)

local Core = {}

-- Marker used to specify children of a node.
Core.Children = Symbol.named("Children")

-- Marker used to specify a callback to receive the underlying Roblox object.
Core.Ref = Symbol.named("Ref")

-- Marker used to specify that a component is a Roact Portal.
Core.Portal = Symbol.named("Portal")

-- Marker used to specify that the value is nothing, because nil cannot be stored in tables.
Core.None = Symbol.named("None")

-- Marker used to specify that the table it is present within is a component.
Core.Element = Symbol.named("Element")

return Core</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="14">
                <Properties>
                  <string name="Name">Event</string>
                  <string name="Source">--[[
	Index into 'Event' to get a prop key for attaching to an event on a
	Roblox Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("Event(%s)"):format(self.name)
	end
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			type = Event,
			name = eventName
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end
})

return Event</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="15">
                <Properties>
                  <string name="Name">GlobalConfig</string>
                  <string name="Source">--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="16">
                <Properties>
                  <string name="Name">Instrumentation</string>
                  <string name="Source">--[[
	An optional instrumentation layer that the reconciler calls into to record
	various events.

	Tracks a number of stats, including:
		Recorded stats:
		- Render count by component
		- Update request count by component
		- Actual update count by component
		- shouldUpdate returned true count by component
		- Time taken to run shouldUpdate
		- Time taken to render by component
		Derivable stats (for profiling manually or with a future tool):
		- Average render time by component
		- Percent of total render time by component
		- Percent of time shouldUpdate returns true
		- Average shouldUpdate time by component
		- Percent of total shouldUpdate time by component
]]

local Instrumentation = {}

local componentStats = {}

--[[
	Determines name of component from the given instance handle and returns a
	stat object from the componentStats table, generating a new one if needed
]]
local function getStatEntry(handle)
	local name
	if handle and handle._element and handle._element.component then
		name = tostring(handle._element.component)
	else
		warn("Component name not valid for " .. tostring(handle._key))
		return nil
	end
	local entry = componentStats[name]
	if not entry then
		entry = {
			-- update requests
			updateReqCount = 0,
			-- actual updates
			didUpdateCount = 0,
			-- time spent in shouldUpdate
			shouldUpdateTime = 0,
			-- number of renders
			renderCount = 0,
			-- total render time spent
			renderTime = 0,
		}
		componentStats[name] = entry
	end

	return entry
end

--[[
	Logs the time taken and resulting value of a Component's shouldUpdate function
]]
function Instrumentation.logShouldUpdate(handle, updateNeeded, shouldUpdateTime)
	-- Grab or create associated entry in stats table
	local statEntry = getStatEntry(handle)
	if statEntry then
		-- Increment the total number of times update was invoked
		statEntry.updateReqCount = statEntry.updateReqCount + 1

		-- Increment (when applicable) total number of times shouldUpdate returned true
		statEntry.didUpdateCount = statEntry.didUpdateCount + (updateNeeded and 1 or 0)

		-- Add time spent checking if an update is needed (in millis) to total time
		statEntry.shouldUpdateTime = statEntry.shouldUpdateTime + shouldUpdateTime * 1000
	end
end

--[[
	Logs the time taken value of a Component's render function
]]
function Instrumentation.logRenderTime(handle, renderTime)
	-- Grab or create associated entry in stats table
	local statEntry = getStatEntry(handle)
	if statEntry then
		-- Increment total render count
		statEntry.renderCount = statEntry.renderCount + 1

		-- Add render time (in millis) to total rendering time
		statEntry.renderTime = statEntry.renderTime + renderTime * 1000
	end
end

--[[
	Clears all the stats collected thus far. Useful for testing and for profiling in the future
]]
function Instrumentation.clearCollectedStats()
	componentStats = {}
end

--[[
	Returns all the stats collected thus far. Useful for testing and for profiling in the future
]]
function Instrumentation.getCollectedStats()
	return componentStats
end

return Instrumentation</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="17">
                <Properties>
                  <string name="Name">PureComponent</string>
                  <string name="Source">--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="18">
                <Properties>
                  <string name="Name">Reconciler</string>
                  <string name="Source"><![CDATA[--[[
	The reconciler uses the virtual DOM generated by components to create a real
	tree of Roblox instances.

	The reonciler has three basic operations:
	* mount (previously reify)
	* reconcile
	* unmount (previously teardown)

	Mounting is the process of creating new components. This is first
	triggered when the user calls `Roact.mount` on an element. This is where the
	structure of the component tree is built, later used and modified by the
	reconciliation and unmounting steps.

	Reconciliation accepts an existing concrete instance tree (created by mount)
	along with a new element that describes the desired tree. The reconciler
	will do the minimum amount of work required to update tree's components to
	match the new element, sometimes invoking mount to create new branches.

	Unmounting destructs for the tree. It will crawl through the tree,
	destroying nodes from the bottom up.

	Much of the reconciler's work is done by Component, which is the base for
	all stateful components in Roact. Components can trigger reconciliation (and
	implicitly, unmounting) via state updates that come with their own caveats.
]]

local Core = require(script.Parent.Core)
local Event = require(script.Parent.Event)
local Change = require(script.Parent.Change)
local getDefaultPropertyValue = require(script.Parent.getDefaultPropertyValue)
local SingleEventManager = require(script.Parent.SingleEventManager)
local Symbol = require(script.Parent.Symbol)
local GlobalConfig = require(script.Parent.GlobalConfig)

local isInstanceHandle = Symbol.named("isInstanceHandle")

local DEFAULT_SOURCE = "\n\t<Use Roact.setGlobalConfig with the 'elementTracing' key to enable detailed tracebacks>\n"

local ElementKind = {
	None = Symbol.named("ElementKind.None"),
	Portal = Symbol.named("ElementKind.Portal"),
	Primitive = Symbol.named("ElementKind.Primitive"),
	Functional = Symbol.named("ElementKind.Functional"),
	Stateful = Symbol.named("ElementKind.Stateful"),
}

--[[
	Sets the value of a reference to a new rendered object.
	Correctly handles both function-style and object-style refs.
]]
local function applyRef(ref, newRbx)
	if ref == nil then
		return
	end

	if type(ref) == "table" then
		ref.current = newRbx
	else
		ref(newRbx)
	end
end

local componentTypesToKinds = {
	["string"] = ElementKind.Primitive,
	["function"] = ElementKind.Functional,
	["table"] = ElementKind.Stateful,
}
local function getElementKind(element)
	local elementType = typeof(element)

	-- We ignore boolean values, which enables using a shorter syntax for
	-- conditionally rendered elements.
	if elementType == "nil" or elementType == "boolean" then
		return ElementKind.None
	end

	if elementType ~= "table" then
		return nil
	end

	local component = element.component

	if component == Core.Portal then
		return ElementKind.Portal
	end

	local componentType = typeof(component)

	return componentTypesToKinds[componentType]
end

local Reconciler = {}

Reconciler._singleEventManager = SingleEventManager.new()

--[[
	Destroy the given Roact instance, all of its descendants, and associated
	Roblox instances owned by the components.
]]
function Reconciler.unmount(instanceHandle)
	local element = instanceHandle._element

	local elementKind = getElementKind(element)

	if elementKind == ElementKind.Primitive then
		-- We're destroying a Roblox Instance-based object

		-- Kill refs before we make changes, since any mutations past this point
		-- aren't relevant to components.
		applyRef(element.props[Core.Ref], nil)

		for _, child in pairs(instanceHandle._children) do
			Reconciler.unmount(child)
		end

		-- Necessary to make sure SingleEventManager doesn't leak references
		Reconciler._singleEventManager:disconnectAll(instanceHandle._rbx)

		instanceHandle._rbx:Destroy()
	elseif elementKind == ElementKind.Functional then
		-- Functional components can return nil
		if instanceHandle._child then
			Reconciler.unmount(instanceHandle._child)
		end
	elseif elementKind == ElementKind.Stateful then
		instanceHandle._instance:_unmount()
	elseif elementKind == ElementKind.Portal then
		for _, child in pairs(instanceHandle._children) do
			Reconciler.unmount(child)
		end
	else
		error(("Cannot unmount invalid Roact instance %q"):format(tostring(element)))
	end
end

--[[
	Public interface to reifier. Hides parameters used when recursing down the
	component tree.
]]
function Reconciler.mount(element, parent, key)
	return Reconciler._mountInternal(element, parent, key)
end

--[[
	Instantiates components to represent the given element.

	Parameters:
		- `element`: The element to mount.
		- `parent`: The Roblox object to contain the contained instances
		- `key`: The Name to give the Roblox instance that gets created
		- `context`: Used to pass Roact context values down the tree

	The structure created by this method is important to the functionality of
	the reconciliation methods; they depend on this structure being well-formed.
]]
function Reconciler._mountInternal(element, parent, key, context)
	local elementKind = getElementKind(element)

	if elementKind == nil then
		error(("Cannot mount invalid Roact element %q"):format(tostring(element)))
	end

	if elementKind == ElementKind.Primitive then
		-- Primitive elements are backed directly by Roblox Instances.

		local rbx = Instance.new(element.component)

		-- Update Roblox properties
		for key, value in pairs(element.props) do
			Reconciler._setRbxProp(rbx, key, value, element)
		end

		-- Create children!
		local children = {}

		if element.props[Core.Children] then
			for key, childElement in pairs(element.props[Core.Children]) do
				local childInstance = Reconciler._mountInternal(childElement, rbx, key, context)

				children[key] = childInstance
			end
		end

		-- This name can be passed through multiple components.
		-- Elements with the same key will be treated as the same
		-- element between reconciles; the old element will be
		-- reconciled to the new element with the same key.
		if key then
			rbx.Name = key
		end

		rbx.Parent = parent

		-- Attach ref values, since the instance is initialized now.
		applyRef(element.props[Core.Ref], rbx)

		return {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
			_children = children,
			_rbx = rbx,
		}
	elseif elementKind == ElementKind.Functional then
		-- Functional elements contain 0 or 1 children.

		local instanceHandle = {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
		}

		local vdom = element.component(element.props)
		if vdom then
			instanceHandle._child = Reconciler._mountInternal(vdom, parent, key, context)
		end

		return instanceHandle
	elseif elementKind == ElementKind.Stateful then
		-- Stateful elements have 0 or 1 children, and also have a backing
		-- instance that can keep state.

		-- We separate the instance's implementation from our handle to it.
		local instanceHandle = {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_child = nil,
		}

		local instance = element.component._new(element.props, context)

		instanceHandle._instance = instance
		instance:_mount(instanceHandle)

		return instanceHandle
	elseif elementKind == ElementKind.Portal then
		-- Portal elements have one or more children.

		local target = element.props.target
		if not target then
			error(("Cannot mount Portal without specifying a target."):format(tostring(element)))
		elseif typeof(target) ~= "Instance" then
			error(("Cannot mount Portal with target of type %q."):format(typeof(target)))
		end

		-- Create children!
		local children = {}

		if element.props[Core.Children] then
			for key, childElement in pairs(element.props[Core.Children]) do
				local childInstance = Reconciler._mountInternal(childElement, target, key, context)

				children[key] = childInstance
			end
		end

		return {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
			_children = children,
			_rbx = target,
		}
	elseif elementKind == ElementKind.None then
		return nil
	end

	error(("Unexpected element kind %s. This is a Roact bug."):format(tostring(elementKind)))
end

--[[
	A public interface around _reconcileInternal
]]
function Reconciler.reconcile(instanceHandle, newElement)
	if instanceHandle == nil or not instanceHandle[isInstanceHandle] then
		local message = (
			"Bad argument #1 to Reconciler.reconcile, expected component instance handle, found %s"
		):format(
			typeof(instanceHandle)
		)

		error(message, 2)
	end

	return Reconciler._reconcileInternal(instanceHandle, newElement)
end

--[[
	Applies the state given by newElement to an existing Roact instance.

	reconcile will return the instance that should be used. This instance can
	be different than the one that was passed in.
]]
function Reconciler._reconcileInternal(instanceHandle, newElement)
	local oldElement = instanceHandle._element

	local newElementKind = getElementKind(newElement)

	if newElementKind == nil then
		error(("Cannot reconcile to invalid Roact element %q"):format(tostring(newElement)))
	end

	if newElementKind == ElementKind.None then
		Reconciler.unmount(instanceHandle)

		return nil
	end

	-- If the element changes type, we assume its subtree will be substantially
	-- different. This lets us skip comparisons of a large swath of nodes.
	if oldElement.component ~= newElement.component then
		if GlobalConfig.getValue("warnOnTypeChange") then
			warn(("A Roact component is changing type from %s to %s during reconciliation!\n"
				.. "This can cause performance issues; see issue #88 for details."):format(
				tostring(oldElement.component),
				tostring(newElement.component)
			))

			print(("Old element source: %s\nNew element source: %s"):format(
				oldElement.source or DEFAULT_SOURCE,
				newElement.source or DEFAULT_SOURCE
			))
		end

		local parent = instanceHandle._parent
		local key = instanceHandle._key

		local context
		if getElementKind(oldElement) == ElementKind.Stateful then
			context = instanceHandle._instance._context
		else
			context = instanceHandle._context
		end

		Reconciler.unmount(instanceHandle)

		local newInstance = Reconciler._mountInternal(newElement, parent, key, context)

		return newInstance
	end

	if newElementKind == ElementKind.Primitive then
		local oldRef = oldElement.props[Core.Ref]
		local newRef = newElement.props[Core.Ref]

		-- Change the ref in one pass before applying any changes.
		-- Roact doesn't provide any guarantees with regards to the sequencing
		-- between refs and other changes in the commit phase.
		if newRef ~= oldRef then
			applyRef(oldRef, nil)
			applyRef(newRef, instanceHandle._rbx)
		end

		-- Update properties and children of the Roblox object.
		Reconciler._reconcilePrimitiveProps(oldElement, newElement, instanceHandle._rbx)
		Reconciler._reconcilePrimitiveChildren(instanceHandle, newElement)

		instanceHandle._element = newElement

		return instanceHandle
	elseif newElementKind == ElementKind.Functional then
		instanceHandle._element = newElement

		local rendered = newElement.component(newElement.props)
		local newChild

		if instanceHandle._child then
			-- Transition from tree to tree, even if 'rendered' is nil
			newChild = Reconciler._reconcileInternal(instanceHandle._child, rendered)
		elseif rendered then
			-- Transition from nil to new tree
			newChild = Reconciler._mountInternal(
				rendered,
				instanceHandle._parent,
				instanceHandle._key,
				instanceHandle._context
			)
		end

		instanceHandle._child = newChild

		return instanceHandle
	elseif newElementKind == ElementKind.Stateful then
		instanceHandle._element = newElement

		-- Stateful elements can take care of themselves.
		instanceHandle._instance:_update(newElement.props)

		return instanceHandle
	elseif newElementKind == ElementKind.Portal then
		if instanceHandle._rbx ~= newElement.props.target then
			local parent = instanceHandle._parent
			local key = instanceHandle._key
			local context = instanceHandle._context

			Reconciler.unmount(instanceHandle)

			local newInstance = Reconciler._mountInternal(newElement, parent, key, context)

			return newInstance
		end

		Reconciler._reconcilePrimitiveChildren(instanceHandle, newElement)

		instanceHandle._element = newElement

		return instanceHandle
	end

	error(("Unexpected element kind %s. This is a Roact bug."):format(tostring(newElementKind)))
end

--[[
	Reconciles the children of an existing Roact instance and the given element.
]]
function Reconciler._reconcilePrimitiveChildren(instance, newElement)
	local elementChildren = newElement.props[Core.Children]

	-- Reconcile existing children that were changed or removed
	for key, childInstance in pairs(instance._children) do
		local childElement = elementChildren and elementChildren[key]

		childInstance = Reconciler._reconcileInternal(childInstance, childElement)

		instance._children[key] = childInstance
	end

	-- Create children that were just added!
	if elementChildren then
		for key, childElement in pairs(elementChildren) do
			-- Update if we didn't hit the child in the previous loop
			if not instance._children[key] then
				local childInstance = Reconciler._mountInternal(childElement, instance._rbx, key, instance._context)
				instance._children[key] = childInstance
			end
		end
	end
end

--[[
	Reconciles the properties between two primitive Roact elements and applies
	the differences to the given Roblox object.
]]
function Reconciler._reconcilePrimitiveProps(fromElement, toElement, rbx)
	local seenProps = {}

	-- Set properties that were set with fromElement
	for key, oldValue in pairs(fromElement.props) do
		seenProps[key] = true

		local newValue = toElement.props[key]

		if oldValue ~= newValue then
			Reconciler._setRbxProp(rbx, key, newValue, toElement)
		end
	end

	-- Set properties that are new in toElement
	for key, newValue in pairs(toElement.props) do
		if not seenProps[key] then
			local oldValue = fromElement.props[key]

			if oldValue ~= newValue then
				Reconciler._setRbxProp(rbx, key, newValue, toElement)
			end
		end
	end
end

--[[
	Used in _setRbxProp to avoid creating a new closure for every property set.
]]
local function set(rbx, key, value)
	rbx[key] = value
end

--[[
	Sets a property on a Roblox object, following Roact's rules for special
	case properties.

	This function can throw a couple different errors. In the future, calls to
	_setRbxProp should be wrapped in a pcall to give better errors to the user.

	For that to be useful, we'll need to attach a 'source' property on every
	element, created using debug.traceback(), that points to where the element
	was created.
]]
function Reconciler._setRbxProp(rbx, key, value, element)
	if type(key) == "string" then
		-- Regular property

		if value == nil then
			-- Here, we assume that any properties for which nil is a valid
			-- value have nil as their default value. This is necessary because
			-- we can't distinguish between a property being set to nil and not
			-- being present at all in a table; we assume the latter.

			local hasProperty, defaultValue = getDefaultPropertyValue(rbx.ClassName, key)

			if hasProperty then
				value = defaultValue
			end
		end

		local success, err = pcall(set, rbx, key, value)

		if not success then
			local source = element.source or DEFAULT_SOURCE

			local message = ("Failed to set property %s on primitive instance of class %s\n%s\n%s"):format(
				key,
				rbx.ClassName,
				err,
				source
			)

			error(message, 0)
		end
	elseif type(key) == "table" then
		-- Special property with extra data attached.

		if key.type == Event then
			if value ~= nil then
				Reconciler._singleEventManager:connect(rbx, key.name, value)
			else
				Reconciler._singleEventManager:disconnect(rbx, key.name)
			end
		elseif key.type == Change then
			if value ~= nil then
				Reconciler._singleEventManager:connectProperty(rbx, key.name, value)
			else
				Reconciler._singleEventManager:disconnectProperty(rbx, key.name)
			end
		else
			local source = element.source or DEFAULT_SOURCE

			-- luacheck: ignore 6
			local message = ("Failed to set special property on primitive instance of class %s\nInvalid special property type %q\n%s"):format(
				rbx.ClassName,
				tostring(key.type),
				source
			)

			error(message, 0)
		end
	elseif type(key) ~= "userdata" then
		-- Userdata values are special markers, usually created by Symbol
		-- They have no data attached other than being unique keys

		local source = element.source or DEFAULT_SOURCE

		local message = ("Properties with a key type of %q are not supported\n%s"):format(
			type(key),
			source
		)

		error(message, 0)
	end
end

return Reconciler
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="19">
                <Properties>
                  <string name="Name">ReconcilerCompat</string>
                  <string name="Source">--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Reconciler = require(script.Parent.Reconciler)

local warnedLocations = {}

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local ReconcilerCompat = {}

--[[
	Exposed as a method so that test cases can override `warn`.
]]
ReconcilerCompat._warn = warn

local function warnOnce(message)
	local trace = debug.traceback(message, 3)
	if warnedLocations[trace] then
		return
	end

	warnedLocations[trace] = true

	ReconcilerCompat._warn(trace)
end

function ReconcilerCompat.reify(...)
	warnOnce(reifyMessage)

	return Reconciler.mount(...)
end

function ReconcilerCompat.teardown(...)
	warnOnce(teardownMessage)

	return Reconciler.unmount(...)
end

return ReconcilerCompat</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="20">
                <Properties>
                  <string name="Name">SingleEventManager</string>
                  <string name="Source"><![CDATA[--[[
	An interface to have one event listener at a time on an event.

	One listener can be registered per SingleEventManager/Instance/Event triple.

	For example:

		myManager:connect(myPart, "Touched", touchedListener)
		myManager:connect(myPart, "Touched", otherTouchedListener)

	If myPart is touched, only `otherTouchedListener` will fire, because the
	first listener was disconnected during the second connect call.

	The hooks provided by SingleEventManager pass the associated Roblox object
	as the first parameter to the callback. This differs from normal
	Roblox events.

	SingleEventManager's public methods operate in terms of instances and string
	keys, differentiating between regular events and property changed signals
	by calling different methods.

	In the internal implementation, everything is handled via indexing by
	instances and event objects themselves. This allows the code to use the same
	structures for both kinds of instance event.
]]

local SingleEventManager = {}

SingleEventManager.__index = SingleEventManager

--[[
	Constructs a `Hook`, which is a bundle containing a method that can be
	updated, as well as the signal connection.
]]
local function createHook(instance, event, method)
	local hook = {
		method = method,
	}

	hook.connection = event:Connect(function(...)
		hook.method(instance, ...)
	end)

	return hook
end

function SingleEventManager.new()
	local self = {
		-- Map<Instance, Map<Event, Hook>>
		_hooks = {},
	}

	setmetatable(self, SingleEventManager)

	return self
end

function SingleEventManager:connect(instance, key, method)
	self:_connectInternal(instance, instance[key], key, method)
end

function SingleEventManager:connectProperty(instance, key, method)
	self:_connectInternal(instance, instance:GetPropertyChangedSignal(key), "Property:" .. key, method)
end

--[[
	Disconnects the hook attached to the event named `key` on the given
	`instance` if there is one, otherwise does nothing.

	Note that `key` must identify a valid property on `instance`, or this method
	will throw.
]]
function SingleEventManager:disconnect(instance, key)
	self:_disconnectInternal(instance, key)
end

--[[
	Disconnects the hook attached to the property changed signal on `instance`
	with the name `key` if there is one, otherwise does nothing.

	Note that `key` must identify a valid property on `instance`, or this method
	will throw.
]]
function SingleEventManager:disconnectProperty(instance, key)
	self:_disconnectInternal(instance, "Property:" .. key)
end

--[[
	Disconnects any hooks managed by SingleEventManager associated with
	`instance`.

	Calling disconnectAll with an untracked instance won't do anything.
]]
function SingleEventManager:disconnectAll(instance)
	local instanceHooks = self._hooks[instance]

	if instanceHooks == nil then
		return
	end

	for _, hook in pairs(instanceHooks) do
		hook.connection:Disconnect()
	end

	self._hooks[instance] = nil
end

--[[
	Creates a hook using the given event and method and associates it with the
	given instance.

	Generally, `event` should directly associated with `instance`, but that's
	unchecked in this code.
]]
function SingleEventManager:_connectInternal(instance, event, key, method)
	local instanceHooks = self._hooks[instance]

	if instanceHooks == nil then
		instanceHooks = {}
		self._hooks[instance] = instanceHooks
	end

	local existingHook = instanceHooks[key]

	if existingHook ~= nil then
		existingHook.method = method
	else
		instanceHooks[key] = createHook(instance, event, method)
	end
end

--[[
	Disconnects a hook associated with the given instance and event if it's
	present, otherwise does nothing.
]]
function SingleEventManager:_disconnectInternal(instance, key)
	local instanceHooks = self._hooks[instance]

	if instanceHooks == nil then
		return
	end

	local hook = instanceHooks[key]

	if hook == nil then
		return
	end

	hook.connection:Disconnect()
	instanceHooks[key] = nil

	-- If there are no hooks left for this instance, we don't need this record.
	if next(instanceHooks) == nil then
		self._hooks[instance] = nil
	end
end

return SingleEventManager
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="21">
                <Properties>
                  <string name="Name">Symbol</string>
                  <string name="Source">--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[[
	Create an unnamed Symbol. Usually, you should create a named Symbol using
	Symbol.named(name)
]]
function Symbol.unnamed()
	local self = newproxy(true)

	getmetatable(self).__tostring = function()
		return "Unnamed Symbol"
	end

	return self
end

return Symbol</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="22">
                <Properties>
                  <string name="Name">createElement</string>
                  <string name="Source">local Core = require(script.Parent.Core)
local GlobalConfig = require(script.Parent.GlobalConfig)

--[[
	Creates a new Roact element of the given type.

	Does not create any concrete objects.
]]
local function createElement(elementType, props, children)
	if elementType == nil then
		error(("Expected elementType as an argument to createElement!"), 2)
	end

	props = props or {}

	if children then
		if props[Core.Children] ~= nil then
			warn("props[Children] was defined but was overridden by third parameter to createElement!")
		end

		props[Core.Children] = children
	end

	local element = {
		type = Core.Element,
		component = elementType,
		props = props,
	}

	if GlobalConfig.getValue("elementTracing") then
		element.source = ("\n%s\n"):format(debug.traceback())
	end

	return element
end

return createElement</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="23">
                <Properties>
                  <string name="Name">createRef</string>
                  <string name="Source">--[[
	Provides an API for acquiring a reference to a reified object. This
	API is designed to mimic React 16.3's createRef API.

	See:
	* https://reactjs.org/docs/refs-and-the-dom.html
	* https://reactjs.org/blog/2018/03/29/react-v-16-3.html#createref-api
]]

local refMetatable = {
	__tostring = function(self)
		return ("RoactReference(%s)"):format(tostring(self.current))
	end,
}

return function()
	return setmetatable({
		current = nil,
	}, refMetatable)
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="24">
                <Properties>
                  <string name="Name">getDefaultPropertyValue</string>
                  <string name="Source">--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultPropertyValue(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultPropertyValue</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="25">
                <Properties>
                  <string name="Name">invalidSetStateMessages</string>
                  <string name="Source">--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]

local invalidSetStateMessages = {}

invalidSetStateMessages["willUpdate"] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages["willUnmount"] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages["shouldUpdate"] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages["init"] = [[
setState cannot be used in the init method.
During init, the component hasn't initialized yet, and isn't ready to render.

Instead, set the `state` value directly:

	self.state = {
		value = "foo"
	}

Check the definition of init in the component %q.]]

invalidSetStateMessages["render"] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["reconcile"] = [[
setState cannot be called while a component is being reified or reconciled.
This is the step where Roact constructs Roblox instances, and starting another
render here would introduce bugs.

Check the component %q to see if setState is being called by:
* a child Ref
* a child Changed event
* a child's render method]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, but Roact couldn't find a
message to display.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="26">
                <Properties>
                  <string name="Name">oneChild</string>
                  <string name="Source">--[[
	Utility to retrieve one child out the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child, but can be passed zero.
]]
local function oneChild(children)
	if not children then
		return
	end

	local key, child = next(children)

	if not child then
		return
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild</string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="27">
          <Properties>
            <string name="Name">services</string>
            <string name="Source">return setmetatable({}, {
    __index = function(self, serviceName)
        local service = game:GetService(serviceName);
        self[serviceName] = service;
        return service;
    end;
})</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>